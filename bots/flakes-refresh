#!/usr/bin/python3
# -*- coding: utf-8 -*-

# This file is part of Cockpit.
#
# Copyright (C) 2018 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

import argparse
import sys
import time
import os
import urllib
import socket
import json

sys.dont_write_bytecode = True

import task

NUMBER_OPEN_ISSUES = 7            # How many issues do we want to have open at a given time?

# How far back does our data go?  If a flake gets fixed but is still
# flaky after this many days, the bots open another issue.

WINDOW_DAYS = 21

# This parses the output JSONL format discussed here, where various
# values are grouped:
#
# https://github.com/cockpit-project/cockpituous/blob/master/learn/README.md

# Here we're looking for a field in a record that only has one value
def value(record, field):
    values = record.get(field, [])
    if len(values) == 1:
        return values[0][0] or ""
    return None

# Here we're looking for the count of a specific field/value in the record
def count(record, field, only):
    values = record.get(field, [])
    for value, count in values:
        if value != only:
            continue
        return count
    return 0

def run(context, verbose=False, **kwargs):
    api = task.github.GitHub()

    open_issues = api.issues(labels=[ "flake" ])
    create_count = NUMBER_OPEN_ISSUES - len(open_issues)

    if create_count <= 0:
        return 0

    if verbose:
        sys.stderr.write("Going to create %s new flake issue(s)\n" % create_count)

    host = os.environ.get("COCKPIT_LEARN_SERVICE_HOST")
    if not host:
        raise RuntimeError("no learn host environment variable: $COCKPIT_LEARN_SERVICE_HOST")
    port = os.environ.get("COCKPIT_LEARN_SERVICE_PORT", "8080")
    url = "http://{0}:{1}/active/statistics.jsonl".format(host, port)

    statistics = [ ]

    # Retrieve the URL
    try:
        req = urllib.request.Request(url)
        with urllib.request.urlopen(req) as f:
            for line in f.readlines():
                try:
                    record = json.loads(line.decode('utf-8'))
                    statistics.append(record)
                except ValueError as ex:
                    sys.stderr.write("{0}: {1}\n".format(url, ex))
    except (ConnectionResetError, urllib.error.URLError, socket.gaierror) as ex:
        sys.stderr.write("{0}: {1}\n".format(url, ex))
        return False

    tests = { }

    for record in statistics:
        test = value(record, "test")
        context = value(record, "context")
        status = value(record, "status")
        tracker = value(record, "tracker")

        # There should only be one of all of these values
        if test is None or status is None:
            continue

        # XXX - check dates and ignore records that have nothing since
        # WINDOW_DAYS ago.

        # Flaky tests only score on those that fail and are not tracked
        if status == "failure" and not tracker:
            merged = count(record, "merged", True)
            not_merged = count(record, "merged", False)
            null_merged = count(record, "merged", None)
            total = merged + not_merged + null_merged

            # And the key is that they were merged anyway
            if total > 10:
                failures = tests.get(test)
                if not failures:
                    tests[test] = failures = [ ]
                failures.append((merged / total, context, record))

    scores = [ ]

    for n, t in tests.items():
        scores.append((sum(map(lambda f: f[0], t))/len(t), n, t))

    closed_issues = api.issues(labels=["flake"], state="closed", since=(time.time() - (WINDOW_DAYS * 86400)))

    def find_in_issues(issues, name):
        for issue in issues:
            if name in issue["title"]:
                return True
        return False

    scores.sort(reverse=True)
    for score, name, failures in scores:
        if find_in_issues(open_issues, name) or find_in_issues(closed_issues, name):
            continue

        if verbose:
            sys.stderr.write("Opening issue for %s\n" % name)
        source = "<details><summary>Source material</summary>\n\n```json\n%s\n```\n</details>\n" % "\n".join(map(lambda f: json.dumps(f[2], indent=2), failures))
        data = {
            "title": "%s is flaky" % name,
            "body": ("\n".join(map(lambda f: "%s%% on %s" % (int(f[0]*100), f[1]), failures)) +
                     "\n\n" + source),
            "labels": [ "flake" ]
        }
        api.post("issues", data)
        create_count -= 1
        if create_count == 0:
            break

    return 0

if __name__ == '__main__':
    task.main(function=run, title="Create issues for test flakes")
